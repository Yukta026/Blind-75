Pacific Atlantic Water Flow
---------------------------
Time Complexity - O(m*n)
Space Complexity - O(m*n)
---------------------------
class Solution {
    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        int m = heights.length;
        int n = heights[0].length;
        boolean[][] pacific = new boolean[m][n];
        boolean[][] atlantic = new boolean[m][n];
// For parsing top and left borders
        for(int i =0;i<m;i++){
            dfs(i,0,pacific,heights);
        }
        for(int j=0;j<n;j++){
            dfs(0,j,pacific,heights);
        }
// For parsing right and bottom borders
        for(int i =0;i<m;i++){
            dfs(i,n-1,atlantic,heights);
        }
        for(int j =0;j<n;j++){
            dfs(m-1,j,atlantic,heights);
        }
        List<List<Integer>> ans = new ArrayList<>();
        
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(pacific[i][j] && atlantic[i][j]){
                    List<Integer> res = new ArrayList<>();
                    res.add(i);
                    res.add(j);
                    ans.add(res);
                }
            }
        }
        return ans;
    }
    public void dfs(int i,int j,boolean[][] visited,int[][] heights){
        visited[i][j] = true;
// Parsing in 4 directions
        int[] dir = {-1,0,1,0,-1};
        int m = heights.length;
        int n = heights[0].length;

        for(int d =0;d<4;d++){
            int di = i + dir[d];
            int dj = j + dir[d+1];

            if(di <0 || dj < 0 || di >= m || dj >= n){
                continue;
            }
            if(visited[di][dj] == true) continue;
            if(heights[di][dj] < heights[i][j]) continue;

            dfs(di,dj,visited,heights);
        }
    }
}
